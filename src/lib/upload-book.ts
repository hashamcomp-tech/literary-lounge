import { doc, setDoc, serverTimestamp, Firestore, increment } from "firebase/firestore";
import { FirebaseStorage } from "firebase/storage";
import { uploadCoverImage } from "./upload-cover";
import { errorEmitter } from '@/firebase/error-emitter';
import { FirestorePermissionError } from '@/firebase/errors';
import { structureBook } from '@/ai/flows/structure-book';

interface Chapter {
  chapterNumber: number;
  content: string;
  title?: string;
}

/**
 * Aggressively strips index entries, watermarks, and digital boilerplate.
 * Targets common patterns like "Topic, 123" or "Page 1 of 500".
 */
function cleanManuscriptContent(text: string): string {
  if (!text) return "";
  
  return text
    // 1. Strip Index entries (e.g., "About.com, 286" or "Topic ... 123")
    .replace(/^[A-Z][a-zA-Z0-9\s.-]+,?\s\.+\s\d+\s*$/gm, "")
    .replace(/^[A-Z][a-zA-Z0-9\s.-]+,\s\d+(?:â€“\d+)?\s*$/gm, "")
    // 2. Strip ISBN, Watermarks, and technical metadata
    .replace(/ISBN\s*(?:-13|-10)?[:\s]+[0-9-]{10,17}/gi, "")
    .replace(/Generated by .*|Downloaded from .*/gi, "")
    .replace(/Page\s+\d+\s+of\s+\d+/gi, "")
    .replace(/Reg\. No\..*$/gim, "")
    // 3. Strip publisher address blocks and legal boilerplate
    .replace(/^[0-9]+\s+[A-Z][a-zA-Z\s.-]+,\s*[A-Z]{2}\s*\d{5}.*$/gm, "")
    .replace(/Published by .* imprint of .*/gi, "")
    .replace(/A CIP catalogue record for this book is available from .*/gi, "")
    .replace(/.*asserted (his|her|their) right to be identified.*/gi, "")
    .replace(/All rights reserved\. No part of this (book|work|text).*/gi, "")
    // 4. Cleanup artifacts and excess whitespace
    .replace(/\n{3,}/g, "\n\n")
    .trim();
}

/**
 * Automatically segments a large body of text into chapters using AI structural clues.
 * Uses exact start phrases provided by AI to find boundaries.
 */
function segmentTextIntoChapters(fullText: string, structure: any): Chapter[] {
  const chapters: Chapter[] = [];
  let currentIndex = 0;

  if (!structure || !structure.chapters || structure.chapters.length === 0) {
    return [{
      chapterNumber: 1,
      title: "Full Volume",
      content: cleanManuscriptContent(fullText)
    }];
  }

  for (let i = 0; i < structure.chapters.length; i++) {
    const current = structure.chapters[i];
    const next = structure.chapters[i + 1];
    
    // Find the start of the current chapter
    const startIndex = fullText.indexOf(current.startPhrase, currentIndex);
    if (startIndex === -1) continue;

    let endIndex = fullText.length;
    if (next) {
      const nextIndex = fullText.indexOf(next.startPhrase, startIndex + current.startPhrase.length);
      if (nextIndex !== -1) {
        endIndex = nextIndex;
      }
    }

    const content = fullText.substring(startIndex, endIndex).trim();
    chapters.push({
      chapterNumber: i + 1,
      title: current.title,
      content: cleanManuscriptContent(content)
    });
    
    currentIndex = startIndex + current.startPhrase.length;
  }

  return chapters;
}

/**
 * Process for publishing novels with automatic AI chapter division.
 * Directly processes the raw manuscript to ensure structural integrity.
 */
export async function uploadBookToCloud({
  db,
  storage,
  bookId,
  title,
  author,
  genres,
  rawContent,
  coverFile,
  ownerId
}: {
  db: Firestore;
  storage: FirebaseStorage;
  bookId: string;
  title: string;
  author: string;
  genres: string[];
  rawContent: string;
  coverFile?: File | null;
  ownerId: string;
}) {
  if (!genres || genres.length === 0) throw new Error("At least one genre is required.");
  if (!rawContent) throw new Error("Manuscript content is empty.");

  // 1. AI Structural Analysis (targeted at first 100k chars to find index)
  const analysisResult = await structureBook({ text: rawContent.substring(0, 100000) });
  const chapters = segmentTextIntoChapters(rawContent, analysisResult);

  // 2. Asset Upload
  let coverURL = null;
  let coverSize = 0;
  if (coverFile && storage) {
    try {
      coverURL = await uploadCoverImage(storage, coverFile, bookId);
      coverSize = coverFile.size;
    } catch (e) {
      console.warn("Cover upload skipped.");
    }
  }

  // 3. Prepare Metadata
  const metadataInfo = {
    author,
    authorLower: author.toLowerCase(),
    bookTitle: title,
    bookTitleLower: title.toLowerCase(),
    lastUpdated: serverTimestamp(),
    ownerId,
    totalChapters: chapters.length,
    genre: genres,
    views: 0,
    coverURL,
    coverSize,
  };

  // 4. Set Root Document
  const bookRef = doc(db, 'books', bookId);
  const rootPayload = {
    title,
    titleLower: title.toLowerCase(),
    author,
    authorLower: author.toLowerCase(),
    genre: genres,
    views: 0,
    isCloud: true,
    ownerId,
    createdAt: serverTimestamp(),
    lastUpdated: serverTimestamp(),
    coverURL,
    coverSize,
    metadata: { info: metadataInfo },
    chapters: chapters.map(ch => ({
      chapterNumber: ch.chapterNumber,
      title: ch.title || `Chapter ${ch.chapterNumber}`
    }))
  };

  await setDoc(bookRef, rootPayload, { merge: true }).catch(async (serverError) => {
    errorEmitter.emit('permission-error', new FirestorePermissionError({
      path: bookRef.path,
      operation: 'write',
      requestResourceData: rootPayload,
    }));
  });

  // 5. Global Stats
  if (coverSize > 0) {
    const statsRef = doc(db, 'stats', 'storageUsage');
    setDoc(statsRef, { storageBytesUsed: increment(coverSize) }, { merge: true }).catch(() => {});
  }

  // 6. Chapter Ingestion
  const chapterPromises = chapters.map((ch) => {
    const chRef = doc(db, 'books', bookId, 'chapters', ch.chapterNumber.toString());
    const chData = {
      chapterNumber: ch.chapterNumber,
      content: ch.content,
      title: ch.title || `Chapter ${ch.chapterNumber}`,
      ownerId,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
    };
    
    return setDoc(chRef, chData, { merge: true }).catch(async (serverError) => {
      errorEmitter.emit('permission-error', new FirestorePermissionError({
        path: chRef.path,
        operation: 'write',
        requestResourceData: chData,
      }));
    });
  });

  await Promise.all(chapterPromises);

  return { bookId, coverURL };
}